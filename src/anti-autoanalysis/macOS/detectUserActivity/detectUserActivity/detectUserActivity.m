//
//  detectUserActivity.m
//  detectUserActivity
//
//  Created by Aaron Lichtman on 5/3/19.
//  Copyright Â© 2019 Aaron Lichtman. All rights reserved.

//  This file displays all detected mouse activity in the terminal.
//  This module serves as a PoC "Reverse Turing Test" in that the malware
//  can figure out if it is running on an automated sandbox by the lack of
//  mouse activity. (As it turns out, all sandboxes use vim religiously.)
//
//  While it is possible to simulate keyboard and mouse activity, not all
//  sandboxes come with the infrastructure for this by default.

//  Acknowledgements
//  -----
//  This code is largely based on Patrick Wardle's (Objective-See) SniffMK project.
//  That project can be found here: https://github.com/objective-see/sniffMK
//  Wardle's comments credit Amit Singh ( http://osxbook.com ), who wrote altermouse.c/alterkeys.c.

//  Compilation and Execution
//  -----
//  $ clang -o detectUserActivity detectUserActivity.m -framework Cocoa
//  $ sudo ./detectUserActivity
//
//  Tested on macOS 10.14.4

#import <Foundation/Foundation.h>
#import <ApplicationServices/ApplicationServices.h>

static CFMachPortRef eventTap = NULL;
static NSMutableArray *mouseEvents = NULL;

/// Returns true if running as root.
bool isRoot() {
    return 0 == geteuid();
}


CGEventRef mouseEventCallback(CGEventTapProxy proxy, CGEventType type,
                              CGEventRef event, void *refcon) {
    
    switch (type) {
        case kCGEventLeftMouseDown:
            NSLog(@"Event: Left mouse down\n");
            break;
        case kCGEventLeftMouseUp:
            NSLog(@"Event: Left mouse up\n");
            break;
        case kCGEventRightMouseDown:
            NSLog(@"Event: Right mouse down\n");
            break;
        case kCGEventRightMouseUp:
            NSLog(@"Event: Right mouse up\n");
            break;
        case kCGEventLeftMouseDragged:
            NSLog(@"Event: Left mouse dragged\n");
            break;
        case kCGEventRightMouseDragged:
            NSLog(@"Event: Right mouse dragged\n");
            break;
        case kCGEventTapDisabledByTimeout:
            CGEventTapEnable(eventTap, true);
            NSLog(@"Event tap timed out: restarting tap");
            return event;
            
        default:
            printf("unknown (%d)", type);
    }

    // Add mouse event to array in anticipation of future features.
    [mouseEvents addObject:(__bridge id _Nonnull)(event)];
    
    // Get mouse coordinates and print them out.
    if ( ! ((kCGEventKeyDown == type) || (kCGEventKeyUp == type)) ) {
        CGPoint location = CGEventGetLocation(event);
        NSLog(@"(x: %f, y: %f)\n\n", location.x, location.y);
    }

    return event;
}


void exitHelper() {
    if (eventTap != NULL) {
        CFRelease(eventTap);
        eventTap = NULL;
    }
    exit(0);
}


int main(int argc, const char * argv[]) {
    NSLog(@"macOS Detect User Activity Test");
    
    CFRunLoopSourceRef runLoopSource = NULL;

    @autoreleasepool {
        if (!isRoot()) {
            NSLog(@"ERR: Must be root.");
            exitHelper();
        }
        
        NSLog(@"Configuring...");
        
        // Set up array to hold all mouse events
        mouseEvents = [NSMutableArray arrayWithCapacity:200];
        
        // Configure eventMask to capture all mouse events.
        CGEventMask eventMask = 0;
        eventMask = CGEventMaskBit(kCGEventLeftMouseDown)    |
                    CGEventMaskBit(kCGEventLeftMouseUp)      |
                    CGEventMaskBit(kCGEventRightMouseDown)   |
                    CGEventMaskBit(kCGEventRightMouseUp)     |
                    CGEventMaskBit(kCGEventLeftMouseDragged) |
                    CGEventMaskBit(kCGEventRightMouseDragged);
        
        // Create eventTap
        eventTap = CGEventTapCreate(kCGSessionEventTap,  // Place event tap where HID system and remote control events enter a login session.
                                    kCGHeadInsertEventTap, // Insert new events at head of list
                                    0, // No extra options
                                    eventMask, // We only care about mouse events
                                    mouseEventCallback, // Every time a mouse event occurs, execute this callback.
                                    NULL);
        if (eventTap == NULL) {
            NSLog(@"ERR: Failed to create event tap.\n");
            exitHelper();
        }
        
        runLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, eventTap, 0);
        
        // Add to current run loop.
        CFRunLoopAddSource(CFRunLoopGetCurrent(), runLoopSource, kCFRunLoopCommonModes);
        
        // Enable tap
        CGEventTapEnable(eventTap, true);
        
        NSLog(@"Checking for mouse activity...\n\n");
        
        CFRunLoopRun();
        
        // TODO: Start timer for 1 minute.
        
        // TODO: At end of timer, pass mouseEvents array to some function that figures out if there is a real person there.
        // Simplest approach is just: "Are there events?"
        
        // TODO: Look into programs that have been written to simulate keyboard and mouse activity.
    }
    return 0;
}

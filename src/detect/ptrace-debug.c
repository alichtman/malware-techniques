#include <stdio.h>
#include <sys/ptrace.h>
#include <stdbool.h>

/**
 * This technique was introduced by Sebastian Auberger in a blog post which can
 * be found here: https://seblau.github.io/posts/linux-anti-debugging.
 *
 * The method relies upon behavior in Linux that dictates only one process may
 * trace another process at a time. All debuggers use a call to ptrace to debug
 * a process, so we can ask for our own process to be traced in order to test if
 * it is being debugged. If we can't ask for our own process to be traced, that
 * means it is already being traced. This is the rationale behind the first ptrace
 * call.
 *
 * Since a reverse engineer could override the ptrace call by preloading a
 * targeted ELF shared object with LD_PRELOAD (demonstrated in blog post) that
 * would, for example, always return 0, we add a second ptrace call that modifies
 * a state variable. If the second ptrace call does not fail in the way we expect
 * it to, the state at the end will not match the correct "no debug" state.
 *
 * These ptrace calls can be nested as many times as you'd like to make reverse
 * engineering difficult.
 * @return True if being debugged, false otherwise.
 */
bool detect_debug() {
	int state = 0;
	if (ptrace(PTRACE_TRACE_ME, 0, 1, 0) == 0) {
		state = 1;
		if (ptrace(PTRACE_TRACE_ME, 0, 1, 0) == - 1) {
			state = 2;
		}
	}

	return state == 2;
}